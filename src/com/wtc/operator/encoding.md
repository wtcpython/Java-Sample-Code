原码是十进制数据的二进制表现形式，最左边为符号位，0为正，1为负

56 -> 0011 1000 最高位为0

一个字节最大值为 0111 1111 即 127

最小值为 1111 1111 即 -127

负数计算：

1000 0000 表示 -0，加 1 后应为 1

实际为 1000 0001，即 -1

因此在原码中，负数数据计算会出问题，为了解决问题，引出了反码

正数的反码不变，反码在原码的基础上，符号位不变，数值取反。

-56 -> 1011 1000 -> 反码：1100 0111

-56 + 1 -> 1100 1000 -> 原码：1011 0111 (-55)

计算成功

那反码就没问题了吗？

-0 -> 1111 1111

-0 + 1 -> 0000 0000 (0)

反码不能解决跨零计算的问题，因为在反码中，存在两个相同的 0

因此要去掉一个 0，补码在负数上，相当于反码加1，正数依旧不变

-4 -> 1000 0100 (原码) -> 1111 1011 (反码) -> 1111 1100 (补码)

-4 + 2 -> 1111 1110 (补码) -> 1111 1101 (反码) -> 1000 0010 (原码) -> -2
